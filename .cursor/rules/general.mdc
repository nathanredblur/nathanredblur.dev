---
alwaysApply: true
---

# Project Rules

## üö® Clarification Before Action (CRITICAL)

**ALWAYS ask clarifying questions before:**

- Creating new files or features
- Fixing complex bugs
- Tasks with 4+ steps
- When there's ambiguity or multiple valid approaches

**Question format:**

```
Before I proceed, I have a few questions:

1. [Question about scope/approach]
   - A) Option one
   - B) Option two

2. [Question about implementation detail]

3. [Question about edge cases]
```

## Base Language and Technologies

- **ALWAYS use TypeScript** in all code files
- **ALWAYS read the `package.json`** before making any changes to determine the technologies used in the project
- **ALWAYS use PNPM** as package manager (never npm or yarn)
- **ALWAYS use English** for all code, comments, documentation, and commit messages
  - ‚ùå NO Spanish in code comments
  - ‚ùå NO Spanish in documentation
  - ‚ùå NO Spanish in variable/function names
  - ‚úÖ English only for all technical content

## Framework Detection

Check `package.json` to determine the framework:

| Framework        | Indicator                        | File Types                   |
| ---------------- | -------------------------------- | ---------------------------- |
| **Astro**        | `astro` in dependencies          | `.astro`, `.tsx` for islands |
| **Vite + React** | `vite` + `react` in dependencies | `.tsx` only                  |

## Tailwind CSS v4

### Detection and Usage

- If the project includes Tailwind CSS, **ONLY use Tailwind** for styling (no inline CSS or other solutions)
- **ALWAYS use Tailwind CSS v4**, which works differently from v3

### Tailwind v4 Configuration

**For Vite projects** (`vite.config.ts`):

```typescript
import { defineConfig } from "vite";
import tailwindcss from "@tailwindcss/vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react(), tailwindcss()],
});
```

**For Astro projects** (`astro.config.mjs`):

```javascript
import { defineConfig } from "astro/config";
import tailwindcss from "@tailwindcss/astro";
import react from "@astrojs/react";

export default defineConfig({
  integrations: [tailwindcss(), react()],
});
```

### Tailwind v4 Import

- In the main CSS file, use:
  ```css
  @import "tailwindcss";
  ```
- **DO NOT use** `@tailwind base;`, `@tailwind components;`, `@tailwind utilities;` (this is v3 syntax)

### Key v4 Differences

1. **Does not require `tailwind.config.js` file** by default
2. **Native Vite plugin** instead of PostCSS
3. **Simplified import** with `@import "tailwindcss"`
4. **Automatic file scanning** without additional configuration

### Color System & Theme Variables

**CRITICAL RULES FOR COLORS**:

1. **NEVER use arbitrary values** like `text-[#c7cfe6]`, `hover:bg-[rgba(167,139,250,0.1)]`
2. **ALWAYS use theme variables** defined in `global.css`
3. **Use Tailwind's color scale** when available (e.g., `bg-purple-500`, `text-slate-700`)

#### Custom Theme Colors (global.css)

Define custom colors in `@theme inline`:

```css
@theme inline {
  /* Custom color scale */
  --color-purple-500: #a78bfa;
  --color-purple-600: #7c3aed;

  /* Theme variables */
  --color-primary: var(--primary);
  --color-accent: var(--accent);
}
```

#### Usage Examples

**‚úÖ CORRECT**:

```tsx
// Use theme variables
<div className="bg-primary text-primary-foreground">
<div className="border-border hover:bg-accent">

// Use Tailwind color scale
<div className="bg-purple-600 text-slate-700">
<div className="hover:bg-purple-500/40"> {/* opacity modifier */}

// Use custom defined colors
<div className="bg-slate-800 border-purple-500">
```

**‚ùå INCORRECT**:

```tsx
// Never use arbitrary values for colors
<div className="text-[#c7cfe6]">
<div className="hover:bg-[rgba(167,139,250,0.1)]">
<div className="min-w-[80px]"> {/* size values are OK if not in theme */}
```

#### When to Define New Colors

1. Check if color exists in Tailwind's default palette
2. Check if color is defined in `global.css` theme
3. If not, add it to `@theme inline` in `global.css`
4. Then use it with proper Tailwind classes

**Resources**:

- [Tailwind v4 Colors](https://tailwindcss.com/docs/colors)
- [Customizing Theme](https://tailwindcss.com/docs/theme#customizing-your-theme)

## Path Aliases Configuration (tsconfig.json)

**CRITICAL**: Path aliases (`@/*`) must be configured correctly for shadcn/ui imports to work.

Reference: [shadcn/ui Vite Installation](https://ui.shadcn.com/docs/installation/vite) | [shadcn/ui Astro Installation](https://ui.shadcn.com/docs/installation/astro)

### For Astro Projects

Add to `tsconfig.json`:

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```

### For Vite + React Projects

Vite splits TypeScript configuration into multiple files. **Both** must be edited:

**tsconfig.json** (root):

```json
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```

**tsconfig.app.json**:

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```

### Vite Config with Path Alias

**vite.config.ts** must also resolve the alias:

```typescript
import path from "path";
import tailwindcss from "@tailwindcss/vite";
import react from "@vitejs/plugin-react";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});
```

**Note**: Requires `@types/node` as dev dependency: `pnpm add -D @types/node`

## Best Practices

### TypeScript

- Use strict types
- Avoid `any`, prefer `unknown` when necessary
- Define interfaces for props and data

```typescript
// ‚úÖ Good
interface ButtonProps {
  variant: "primary" | "secondary";
  onClick: () => void;
}

const SIZES = ["sm", "md", "lg"] as const;
type Size = (typeof SIZES)[number];

// ‚ùå Bad
const handleClick = (data: any) => { ... }
```

### Components

- Functional components with TypeScript
- Typed props with interfaces
- Use composition over inheritance

### React Performance Optimization

**CRITICAL RULES FOR CONSTANTS AND FUNCTIONS**:

#### 1Ô∏è‚É£ **Static Data - Define Outside Component**

‚ùå **INCORRECT** - Using `useMemo` for static data:

```tsx
const MyComponent = () => {
  const OPTIONS = useMemo(
    () => [
      { id: 1, name: "Option 1" },
      { id: 2, name: "Option 2" },
    ],
    []
  );

  const SLIDER_CLASS = useMemo(() => "w-full h-4 ...", []);
  // ...
};
```

‚úÖ **CORRECT** - Define as constants outside component:

```tsx
// Constants defined once, shared across all instances
const OPTIONS = [
  { id: 1, name: "Option 1" },
  { id: 2, name: "Option 2" },
] as const;

const SLIDER_CLASS_NAME = "w-full h-4 bg-gray-200 ...";

const MyComponent = () => {
  // Component code using OPTIONS and SLIDER_CLASS_NAME
};
```

**Why?**

- No memory allocation per component instance
- No dependency tracking overhead
- Better tree-shaking
- Easier to test
- Can be imported by other modules

#### 2Ô∏è‚É£ **Pure Functions - Define Outside Component**

‚ùå **INCORRECT** - Using `useCallback` for pure functions:

```tsx
const MyComponent = ({ data }: Props) => {
  const formatData = useCallback((item: Item) => {
    return item.name.toUpperCase();
  }, []);
  // ...
};
```

‚úÖ **CORRECT** - Define as pure function outside:

```tsx
// Pure function outside component
function formatData(item: Item): string {
  return item.name.toUpperCase();
}

const MyComponent = ({ data }: Props) => {
  // Use formatData directly
  return <div>{formatData(data)}</div>;
};
```

**Why?**

- No closure creation
- No memoization overhead
- Easier to unit test
- Better code organization
- Can be shared across components

#### 3Ô∏è‚É£ **When to Use `useCallback`**

‚úÖ **USE `useCallback`** when the function:

- Depends on props or state
- Uses hooks
- Needs access to component's closure
- Is passed as a prop to memoized children

```tsx
const MyComponent = ({ onSave }: Props) => {
  const [data, setData] = useState({});

  // ‚úÖ Needs state - use useCallback
  const handleSubmit = useCallback(() => {
    onSave(data);
  }, [data, onSave]);

  return <MemoizedChild onSubmit={handleSubmit} />;
};
```

‚ùå **DON'T USE `useCallback`** when the function:

- Is pure (doesn't use props/state)
- Can receive all data via parameters
- Is only used internally without passing as prop

#### 4Ô∏è‚É£ **When to Use `useMemo`**

‚úÖ **USE `useMemo`** for:

- Expensive computations
- Derived data from props/state
- Object/array references passed to memoized children

```tsx
const MyComponent = ({ items }: Props) => {
  // ‚úÖ Expensive computation - use useMemo
  const sortedItems = useMemo(() => {
    return [...items].sort((a, b) => a.value - b.value);
  }, [items]);

  return <MemoizedList items={sortedItems} />;
};
```

‚ùå **DON'T USE `useMemo`** for:

- Static data (use constants outside component)
- Simple transformations (the memoization overhead isn't worth it)
- Strings or primitives that don't change

#### 5Ô∏è‚É£ **Component Memoization**

Use `React.memo()` when:

- Component renders often with same props
- Component is expensive to render
- Parent re-renders frequently but props rarely change

```tsx
// ‚úÖ Memoize expensive components
const ExpensiveList = memo(({ items }: Props) => {
  // Expensive rendering logic
});

// With custom comparison
const SmartComponent = memo(
  (props: Props) => {
    /* ... */
  },
  (prevProps, nextProps) => {
    // Return true if props are equal (skip re-render)
    return prevProps.id === nextProps.id;
  }
);
```

#### 6Ô∏è‚É£ **Optimization Checklist**

Before optimizing, ask:

1. **Is it static?** ‚Üí Move outside component as constant
2. **Is it a pure function?** ‚Üí Move outside component as function
3. **Does it depend on props/state?** ‚Üí Consider `useCallback`/`useMemo`
4. **Is the component expensive?** ‚Üí Consider `memo()`
5. **Is there a measurable performance issue?** ‚Üí Profile first!

**Remember**: Premature optimization is bad, but understanding these patterns helps write efficient code from the start.

### Styling with Tailwind

- Use Tailwind utility classes
- **NEVER use `<style>` tags** - always use Tailwind classes instead
- Avoid custom CSS unless absolutely necessary
- Use Tailwind responsive variants (`sm:`, `md:`, `lg:`, etc.)
- Leverage state classes (`hover:`, `focus:`, `active:`, etc.)
- For animations, use Tailwind's built-in animation utilities (`animate-pulse`, `animate-spin`, etc.)

#### Converting CSS to Tailwind

When removing `<style>` blocks:

1. **Identify common patterns** before converting
2. **Create reusable components** for repeated class combinations
3. **Use `cn()` utility** for conditional classes
4. **Maintain consistency** with existing Tailwind patterns

**Example - Before:**

```tsx
<div className="panel">
  <style>{`
    .panel {
      background: rgba(30, 41, 59, 0.5);
      border: 1px solid #334155;
      border-radius: 0.375rem;
      padding: 0.75rem;
    }
  `}</style>
</div>
```

**After:**

```tsx
<div className="bg-slate-800/50 border border-slate-700 rounded-md p-3">
  {/* No style tag needed */}
</div>
```

## Astro-Specific Rules

When project uses Astro:

### File Organization

```
src/
‚îú‚îÄ‚îÄ pages/           # .astro files for routes
‚îú‚îÄ‚îÄ layouts/         # .astro layout components
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/          # shadcn/ui components (.tsx)
‚îÇ   ‚îî‚îÄ‚îÄ islands/     # Interactive React components (.tsx)
‚îî‚îÄ‚îÄ content/         # Content collections (if blog/docs)
```

### Client Directives

```astro
<!-- Prefer lazy hydration -->
<InteractiveComponent client:visible />
<SearchBar client:idle />

<!-- Only when immediately needed -->
<CriticalWidget client:load />

<!-- Never hydrate (static only) -->
<StaticCard />
```

### Best Practices

- Use `.astro` for static content
- Use React (`.tsx`) only for interactive islands
- Leverage content collections for blogs/docs
- Prefer static generation over SSR

## Vite + React Specific Rules

When project uses Vite + React:

### File Organization

```
src/
‚îú‚îÄ‚îÄ pages/           # Route components
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îî‚îÄ‚îÄ ui/          # shadcn/ui components
‚îú‚îÄ‚îÄ stores/          # Zustand stores
‚îú‚îÄ‚îÄ lib/             # Utilities
‚îî‚îÄ‚îÄ App.tsx          # Main app with router
```

### Routing

```tsx
import { lazy, Suspense } from "react";
import { BrowserRouter, Routes, Route } from "react-router-dom";

// Lazy load routes
const Home = lazy(() => import("./pages/Home"));
const About = lazy(() => import("./pages/About"));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<Loading />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

## shadcn/ui Components

**Reference**: [shadcn/ui Astro](https://ui.shadcn.com/docs/installation/astro) | [shadcn/ui Vite](https://ui.shadcn.com/docs/installation/vite)

### Component System

- **ALWAYS use shadcn/ui** for UI components when available
- Install components on-demand: `pnpm dlx shadcn@latest add <component-name>`
- Components are copied to `src/components/ui/` and fully customizable
- **Official Component List**: https://ui.shadcn.com/docs/components

### Installation Examples

```bash
# Initialize shadcn/ui (first time setup)
pnpm dlx shadcn@latest init

# Install Button component
pnpm dlx shadcn@latest add button

# Install multiple components
pnpm dlx shadcn@latest add button dialog card
```

### Component Usage

- Import from `@/components/ui/component-name`
- Components use Tailwind CSS v4 and are pre-styled
- Customize via Tailwind classes or by editing the component file
- Use `cn()` utility from `@/lib/utils` for conditional classes

### Usage in Astro

```astro
---
import { Button } from "@/components/ui/button"
---

<html lang="en">
  <body>
    <div class="grid place-items-center h-screen">
      <!-- Use client:load for interactive components -->
      <Button client:load>Click me</Button>
    </div>
  </body>
</html>
```

### Usage in Vite + React

```tsx
import { Button } from "@/components/ui/button";

function App() {
  return (
    <div className="flex min-h-svh flex-col items-center justify-center">
      <Button>Click me</Button>
    </div>
  );
}
```

### Icons with Lucide

- **ALWAYS use Lucide React** for icons
- Already included as `lucide-react` dependency
- **Icon Directory**: https://www.shadcn.io/icons/lucide (1,636+ icons)

```typescript
import { Heart, Star, Download } from 'lucide-react';

<Heart className="size-4" />
<Star className="size-5 text-yellow-500" />
```

### Best Practices

- Check if component exists in shadcn before creating custom
- Maintain consistent styling across all shadcn components
- Use component variants when available (e.g., `variant="outline"`)
- Keep icon sizes consistent (typically `size-4` or `size-5`)

## DRY Principle - Component Reusability

### Identifying Repetitive Patterns

When you notice the same class combinations appearing 3+ times:

1. **Create a reusable component** in `src/components/ui/`
2. **Extract common props** into interfaces
3. **Document the component** with JSDoc comments
4. **Update existing code** to use the new component

### Common Reusable Component Patterns

#### Panel Components

For consistent panel layouts:

```tsx
// src/components/ui/panel.tsx
export function Panel({ title, onClose, children }: PanelProps) {
  return (
    <div className="bg-slate-800/50 border border-slate-700 rounded-md p-3">
      <div className="flex justify-between items-center mb-3">
        <h3 className="text-xs font-bold uppercase tracking-wider text-slate-400 m-0">
          {title}
        </h3>
        {onClose && <Button onClick={onClose}>‚úï</Button>}
      </div>
      {children}
    </div>
  );
}
```

#### Form Field Groups

For consistent form field styling:

```tsx
// src/components/ui/field-group.tsx
export function FieldGroup({ label, children }: FieldGroupProps) {
  return (
    <div className="flex flex-col gap-1.5">
      <label className="text-xs font-semibold text-slate-400 uppercase tracking-wide">
        {label}
      </label>
      {children}
    </div>
  );
}
```

#### Empty States

For consistent empty state messaging:

```tsx
// src/components/ui/empty-state.tsx
export function EmptyState({
  icon: Icon,
  title,
  description,
}: EmptyStateProps) {
  return (
    <div className="flex flex-col items-center gap-2 py-8 px-4 text-slate-400">
      <Icon size={48} className="opacity-30" />
      <p className="text-xs font-semibold m-0">{title}</p>
      {description && <span className="text-[0.6875rem]">{description}</span>}
    </div>
  );
}
```

### Benefits of Reusable Components

- ‚úÖ **Consistency**: Same look & feel across the app
- ‚úÖ **Maintainability**: Change once, update everywhere
- ‚úÖ **Readability**: Less visual clutter in component code
- ‚úÖ **Type Safety**: Props validation with TypeScript
- ‚úÖ **Performance**: Can optimize in one place

## State Management

### Local State vs Global State

- **Use `useState`** for component-local state
- **Use Zustand** for global state that needs to be accessed across components
- **Avoid prop drilling** - if passing props through 3+ levels, consider global state

### Zustand Store Pattern

For features like dialogs, toasts, or global UI state:

```tsx
// src/stores/useMyStore.ts
import { create } from "zustand";

interface MyState {
  isOpen: boolean;
  data: any;
}

interface MyActions {
  open: (data: any) => void;
  close: () => void;
}

export const useMyStore = create<MyState & MyActions>((set) => ({
  isOpen: false,
  data: null,

  open: (data) => set({ isOpen: true, data }),
  close: () => set({ isOpen: false, data: null }),
}));

// Usage in component
function MyComponent() {
  const { isOpen, open, close } = useMyStore();
  // ...
}
```

### When to Use Zustand

‚úÖ **Use Zustand for:**

- Global UI state (modals, toasts, sidebars)
- Shared data accessed by many components
- State that needs to persist across route changes
- Complex state that causes excessive prop drilling

‚ùå **Don't use Zustand for:**

- Form state (use controlled components or React Hook Form)
- Derived state (use `useMemo`)
- Server state (use React Query or similar)
- Simple parent-child communication (use props)

## Biome (Linting & Formatting)

### Configuration (`biome.json`)

```json
{
  "$schema": "https://biomejs.dev/schemas/1.9.4/schema.json",
  "vcs": {
    "enabled": true,
    "clientKind": "git",
    "useIgnoreFile": true
  },
  "organizeImports": {
    "enabled": true
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true
    }
  },
  "formatter": {
    "enabled": true,
    "indentStyle": "tab",
    "lineWidth": 100
  }
}
```

### Commands

```bash
pnpm biome check .          # Check all
pnpm biome check --write .  # Fix all
pnpm biome format .         # Format only
```

## Vitest (Testing)

### Configuration (`vitest.config.ts`)

```typescript
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    globals: true,
    environment: "jsdom",
    setupFiles: ["./tests/setup.ts"],
  },
});
```

### Test Structure

```typescript
import { describe, it, expect } from "vitest";

describe("MyComponent", () => {
  it("should render correctly", () => {
    // Test implementation
  });
});
```

### Commands

```bash
pnpm test           # Run tests
pnpm test:watch     # Watch mode
pnpm test:coverage  # With coverage
```

## Documentation Policy

**CRITICAL**: Do NOT create documentation files unless:

1. **Explicitly requested by the user**, OR
2. **Critical for future iterations** (either in this chat or a new one)

Examples of when NOT to create docs:

- ‚ùå After implementing a feature (unless asked)
- ‚ùå "For reference" or "for completeness"
- ‚ùå Summary files, optimization reports, etc.

Examples of when TO create docs:

- ‚úÖ User explicitly asks: "document this"
- ‚úÖ Complex system that will be hard to understand later without docs
- ‚úÖ API contracts or interfaces that other developers will use

**Default behavior**: Focus on code implementation, not documentation.

## Code Cleanup & Dead Code Detection

### Using knip for Dead Code Detection

This project uses **knip** to detect unused files, dependencies, and exports.

#### Running the Tool

```bash
# Run dead code detection
pnpm lint:unused
```

#### When to Run Cleanup

- **ALWAYS run `pnpm lint:unused`** when the user asks to:

  - "Clean up the code"
  - "Clean up the repository"
  - "Find unused code"
  - "Remove dead code"
  - Any similar cleanup request

- **Suggest running cleanup** periodically:
  - After completing a major feature
  - When refactoring large portions of code
  - Before major releases
  - If the codebase feels bloated or slow to build

#### What knip Detects

1. **Unused files**: Files not imported anywhere
2. **Unused dependencies**: Packages in `package.json` not used in code
3. **Unused exports**: Functions, types, or constants exported but never imported
4. **Unused types**: TypeScript types/interfaces not referenced

#### Cleanup Workflow

1. Run `pnpm lint:unused` to get the report
2. Review the results carefully (some exports may be intentionally public APIs)
3. Delete unused files
4. Remove unused dependencies with `pnpm remove <package-name>`
5. Remove or mark unused exports as internal
6. Run `pnpm lint:unused` again to verify cleanup

## Internal Links (Astro)

**CRITICAL**: All internal links MUST end with a trailing slash (`/`).

```markdown
‚úÖ [Link text](/posts/my-post-slug/)
‚úÖ [Link text](/about/)
‚ùå [Link text](/posts/my-post-slug)
‚ùå [Link text](/about)
```

**Why?** Astro generates directories for each page. Without the trailing slash, some servers may redirect or fail to resolve the URL correctly.

## Before Each Change Checklist

1. [ ] Read `package.json` - identify framework (Astro vs Vite)
2. [ ] Verify the Tailwind version (must be v4)
3. [ ] Check if shadcn component exists before creating custom UI
4. [ ] **Check for existing reusable components** in `src/components/ui/`
5. [ ] **Identify repetitive patterns** and consider creating new reusable components
6. [ ] Confirm the project structure
7. [ ] Respect existing code conventions
8. [ ] Use Lucide icons from `lucide-react` package
9. [ ] **Never use `<style>` tags** - use Tailwind classes instead
10. [ ] **Never use arbitrary color values** - use theme variables
11. [ ] For 4+ step tasks: **ASK CLARIFYING QUESTIONS FIRST**
12. [ ] **Do NOT create documentation** unless explicitly requested
13. [ ] Use English only
14. [ ] Use PNPM only (never npm or yarn)
15. [ ] **Internal links MUST end with trailing slash** (`/`)
